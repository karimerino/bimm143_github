{
  "hash": "27bdda2f6c2120b8254f684dafca6393",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R Functions Lab Class 6\"\nauthor: \"Carolina Merino\"\nformat: pdf\n---\nAll functions in R have at least 3 things:\n\n- A **name**, we pick this and use it to call the function.\n- Input **arguments**, there can be multiple comma seperated inputs to the function.\n- The **body**, lines of R code that do the work of the function.\n\nOur first wee function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x) {\n  x + 1\n}\n```\n:::\n\n\nLet's test our function\n\n::: {.cell}\n\n```{.r .cell-code}\nadd <- function(x, y = 0) {\nsum(x) + y\n}\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd(c(1, 2, 3), y = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\nLet's try something more interesting. Make a sequence generation tool.\n\nThe `sample()` function could be useful here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(1:10, size = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 6 8\n```\n\n\n:::\n:::\n\n\nChange this to work with nucleotides A C G and T and return a 3 of them\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- c(\"A\", \"C\", \"G\", \"T\")\nsample(n, size = 15, replace = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"C\" \"A\" \"C\" \"C\" \"A\" \"A\" \"T\" \"G\" \"G\" \"A\" \"C\" \"A\" \"G\" \"A\"\n```\n\n\n:::\n:::\n\nTurn this snippet into a function that returns a user specificied length dna sequence. Let's call it\n`generate_dna()`...\n\n**note** I want the option to return a single element character vector with my sequence all together like this: \"GGAGTAC\" the code below achieves that\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_dna <- function(length) {\n  # Define nucleotides\n  nucleotides <- c(\"A\", \"C\", \"G\", \"T\")\n  \n  # Sample nucleotides with replacement\n  dna_vector <- sample(nucleotides, size = length, replace = TRUE)\n  \n  # Optional: print a message\n  cat(\"Well done you!\\n\")\n  \n  # Combine into a single string\n  dna_sequence <- paste(dna_vector, collapse = \"\")\n  \n  # Return the sequence\n  return(dna_sequence)\n}\n\n# Example usage:\ngenerate_dna(15)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWell done you!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"GATTGTGATAGACAC\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# See data for 15 dna sequence and for 25 dna sequence\ngenerate_dna(15)   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWell done you!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"GTGCGGCCTCCCCCC\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngenerate_dna(25)   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nWell done you!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"CCAGCTACGACAGGCCTGGAATGGG\"\n```\n\n\n:::\n:::\n\n\nNow to generate a DNA sequence as either a single string or a vector of nucleotides\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to generate a random DNA sequence\n# fasta = TRUE returns a single string, FALSE returns a vector\ngenerate_dna <- function(length, fasta = TRUE) {\n  nucleotides <- c(\"A\", \"C\", \"G\", \"T\")\n  dna_vector <- sample(nucleotides, size = length, replace = TRUE)\n  \n  if(fasta) {\n    paste(dna_vector, collapse = \"\")  # single string\n  } else {\n    dna_vector  # vector of letters\n  }\n}\n\n# Examples:\ngenerate_dna(10)                  # default fasta = TRUE, returns \"GGATACGCTA\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ACGCTGCGCG\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngenerate_dna(10, fasta = FALSE)   # returns vector c(\"G\",\"G\",\"A\",...)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"T\" \"T\" \"G\" \"A\" \"C\" \"A\" \"A\" \"G\" \"T\" \"G\"\n```\n\n\n:::\n:::\n\n\n## A more advanced example:\n\nMake a third function that generates a protein sequence of a user specified length and format\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to generate a random protein sequence\n# fasta = TRUE returns a single string, FALSE returns a vector of amino acids\ngenerate_protein <- function(length, fasta = TRUE) {\n  # Define the 20 standard amino acids\n  amino_acids <- c(\"A\", \"R\", \"N\", \"D\", \"C\", \"Q\", \"E\", \"G\",\n                   \"H\", \"I\", \"L\", \"K\", \"M\", \"F\", \"P\", \"S\",\n                   \"T\", \"W\", \"Y\", \"V\")\n  \n  # Sample amino acids with replacement\n  protein_vector <- sample(amino_acids, size = length, replace = TRUE)\n  \n  # Return as single string or vector\n  if(fasta) {\n    paste(protein_vector, collapse = \"\")  # combine into one string\n  } else {\n    protein_vector  # return as vector of letters\n  }\n}\n\n# Examples:\ngenerate_protein(10)               # returns single string like \"MKTAGLIPRY\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"FHNYVKEHNA\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngenerate_protein(10, fasta = FALSE) # returns vector c(\"M\",\"K\",\"T\",...)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"V\" \"D\" \"E\" \"V\" \"K\" \"A\" \"D\" \"K\" \"V\" \"I\"\n```\n\n\n:::\n:::\n\n> Q. Generate random protein sequences between lengths 5 and 12 amino acids\n\nQuestions to answer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_protein(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"FSCHM\"\n```\n\n\n:::\n\n```{.r .cell-code}\ngenerate_protein(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SSLLVP\"\n```\n\n\n:::\n:::\n\nOne approach is to do this by brute force calling our function for each length 5 to 12.\n\nAnother approach is to write a `for()` loop to itterate over the input valued 5 to 12\n\nA very useful third R specific approach is to use the `sapply()` function\n\n\nThis format, takes a lot of effort..\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sequence of lengths\nseq_lengths <- 6:12\n\n# Loop over each length\nfor (i in seq_lengths) {\n  dna_seq <- generate_dna(i)   # call your generate_dna() function\n  cat(\"Length\", i, \"->\", dna_seq, \"\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLength 6 -> GGAATC \nLength 7 -> CACAATT \nLength 8 -> GTAACACA \nLength 9 -> TAGTAGCGT \nLength 10 -> GCGAGGTGAC \nLength 11 -> CATTACGCTGT \nLength 12 -> CCTCGTTGCCGC \n```\n\n\n:::\n:::\n\nLet's do the `sapply()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sequence of lengths\nseq_lengths <- 6:12\n\n# Generate DNA sequences as single strings\ndna_sequences <- sapply(seq_lengths, function(len) generate_dna(len, fasta = TRUE))\n\n# Show results\ndna_sequences\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"CGCCCT\"       \"AAAGCTC\"      \"TGGCATAA\"     \"TTGTATCCT\"    \"AAACTCGGCA\"  \n[6] \"ATGCGTGTCCT\"  \"CTCACGCGCCGG\"\n```\n\n\n:::\n:::\n\nEven more simple...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(5:12, generate_protein)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"TVNKP\"        \"DQQVFQ\"       \"KSLILRI\"      \"EMNMIEVC\"     \"MDRMAWTED\"   \n[6] \"DNYWFETTEK\"   \"CNFPRTVCMFI\"  \"QSDHGRQEIRDC\"\n```\n\n\n:::\n:::\n\n**Key-Point**: Wrting functions in R is doable but not the easiest thing. Starting with a working snippet of code and then using LLM tools to improve and generalize your function code is a productive approach.\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}